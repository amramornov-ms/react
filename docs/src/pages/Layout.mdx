export const meta = {
  title: 'Layout Components',
  previous: { name: 'Colors', url: 'colors' },
  next: { name: 'Integrate Custom Components', url: 'integrate-custom-components' },
}

## Overview

The following components are introduced by Stardust to handle layout aspects:

- `Flex` - designed for layout in one dimension, either a row or a column
- `Grid` - designed for two-dimensional layout, rows and columns at the same time

### Flex vs Grid

Sometimes it might not be evident if some particular case is a case of 1D (i.e. `Flex`) or 2D (i.e. `Grid`) layout. As a result, quite often `Grid` component is used at places where it is sufficient to use `Flex`.

Here is the question you might ask yourself to decide on that:

- do I only need to control the layout by row <strong>or</strong> column? – if yes, use `Flex`.
- do I need to control the layout by row <strong>and</strong> column? – if yes, use `Grid`.

## Flex recipies

There are several advices that might help when using `Flex` component.

### Flex.Item should be used sparingly

<blockquote>
  Use <code>Flex.Item</code> component to wrap child elements only in case if their flex styles
  should be overriden.
</blockquote>

There is no strict need to use `Flex.Item` component as a direct child of `Flex` - one may use `Flex.Item` component only when it is necessary to tweak flex styles of individual child item.

    <ExampleSnippet
      render={() => (
        <Flex gap="gap.small">
          <Button content="Accept" />
          <Button content="Deny" />
        </Flex>
      )}
    />

As a consequence of this:

<blockquote>
Each `Flex.Item` element being introduced without any props specified should be considered for removal.
</blockquote>
    
    <ExampleSnippet
      render={() => (
        <Flex gap="gap.small">
          <Button content="Accept" />
          <Flex.Item>
            <Button content="Deny" />
          </Flex.Item>
        </Flex>
      )}
    />
    
### Optimize amount of DOM elements rendered

Flex component was designed being able to address all flexbox layout scenarios with minimal amount of DOM elements rendered. In addition, there are props to address most common [flexbox usage scenarios](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Typical_Use_Cases_of_Flexbox) (e.g. `push` prop) - the value of these props is that they introduce the least amount of DOM elements necessary to accomplish corresponding use-case.

Let's consider one of the most representative examples - a navigation menu. Suppose that we want a menu bar with logo on the left side and set of nav links on the right.

Quite often this is achieved by introducing a top-level flex container with two children: first is a logo, and the second one is another container (`Flex`, renders to `<div />`)}) with a group of buttons:

    <ExampleSnippet
      render={() => (
        <Flex space="between">
          <Button content="Logo" icon="chess rook" />
          <Flex gap="gap.small">
            <Button content="Page 1" />
            <Button content="Page 2" />
            <Button content="Page 3" />
          </Flex>
        </Flex>
      )}
    />

It turns out that this approach introduces unnecessary nesting level - it is possible to achieve the same goal by using just top-level container, with no buttons container:

    <ExampleSnippet
      render={() => (
        <Flex gap="gap.small">
          <Button content="Logo" icon="chess rook" />
          <Flex.Item push>
            <Button content="Page 1" />
          </Flex.Item>
          <Button content="Page 2" />
          <Button content="Page 3" />
        </Flex>
      )}
    />

Note that `Flex.Item` doesn't result in any additional DOM element rendered - its sole purpose is just to pass style props to its child.

<blockquote>
  Consider to review set of examples on the `Flex` page - as there might be an example that suits
  your needs. **Each of these examples is optimized in terms of DOM elements rendered**.
</blockquote>
